<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Programming in the 21st Century</title>
<link rel="self" href="http://prog21.dadgum.com/atom.xml"/>
<link rel="alternate" href="http://prog21.dadgum.com/"/>
<id>http://prog21.dadgum.com/</id>
<updated>2016-10-16T00:00:00-06:00</updated>
<entry>
<title>Being More Than "Just the Programmer"</title>
<link rel="alternate" type="text/html" href="http://prog21.dadgum.com/224.html"/>
<id>http://prog21.dadgum.com/224.html</id>
<published>2016-10-16T00:00:00-06:00</published>
<updated>2016-10-16T00:00:00-06:00</updated>
<author><name>James Hague</name></author>
<content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>There's a strange dichotomy that college doesn't prepare computer science majors for: knowing how to <i>program</i> is a <a href="http://prog21.dadgum.com/132.html">huge benefit</a> if you want to create something new and useful, but as a <i>programmer</i> you're often viewed as the implementer of someone else's vision--as just the programmer--and have limited say in crafting the application as a whole.</p><p>(Note that here I'm using "application as a whole" to mean the feature set and experience of using the app, not the underlying architecture.)</p><p>In my <a href="http://prog21.dadgum.com/137.html">first game development job</a> writing 16-bit console games, I naively expected there to be a blend of coding and design, like there was when I was writing my own games for home computer magazines, but the two were in different departments in different locations in the rented office park space. It had never occurred to me that a game could be failing because of poor design, yet I wouldn't be able to do anything about it, not having a title with "design" in it. I came out of that experience realizing that I needed to be more than an implementer.</p><p>I wanted to write up some tips for people in similar situations, people who want to be more than just the programmer.</p><p><b>Go through some formalities to prove that you have domain knowledge.</b> You might <i>think</i> you know how to design good user interfaces, but why should anyone listen to you? Buy and read the top books in the field, have them at your desk, and use them to cite guidelines. Or take a class, which might be less efficient than reading on your own, but it's concrete and carries more weight than vague, self-directed learning.</p><p><b>Don't get into technical details when it doesn't matter.</b> "Why is that going to take three weeks to finish?" "Well, there's a new version of the library that doesn't fully work with the C++11 codebase that we're using so I'm going to have to refactor a few classes, and also there are issues with move semantics in the new compiler, so..." No matter how you say this, it sounds like complaining, and you get a reputation as the programmer who spouts technical mumbo jumbo. Sure, talk tech with the right people, but phrase things in terms of the project--not the code--otherwise.</p><p><b>Don't get into programming or technology arguments, ever.</b> Just don't. Again, this is usually thinking on the wrong level, and you don't want to advertise that. There's also this <a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a> quote that I love:</p><blockquote><p>You know, you shouldn't trust us intelligent programmers. We can think up such good arguments for convincing ourselves and each other of the utterly absurd. </p></blockquote><p><b>Get to know people in departments whose work interests you.</b> Continuing the user interface example from above, go talk to the UX folks. Learn what they like and don't like and why they've made certain decisions. They'll be glad that someone is taking an interest, and you'll be learning from people doing the work professionally.</p><p><b>Build prototypes to demonstrate ideas.</b> If you jump in and do work that someone else is supposed to do, like changing the game design, then that's not going to turn out well. A better approach is to build a small prototype of a way you think something should work and get feedback. Take the feedback to heart and make changes based on it (also good, because you're showing people you value their opinions). Sometimes these prototypes will fall flat, but other times you'll have a stream of people stopping by your desk to see what they've heard about.</p></div></content>
</entry>
<entry>
<title>The New Minimalism</title>
<link rel="alternate" type="text/html" href="http://prog21.dadgum.com/223.html"/>
<id>http://prog21.dadgum.com/223.html</id>
<published>2016-10-12T00:00:00-06:00</published>
<updated>2016-10-12T00:00:00-06:00</updated>
<author><name>James Hague</name></author>
<content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>You don't know minimalism until you've spent time in the <a href="http://prog21.dadgum.com/33.html">Forth</a> community. There are recurring debates about whether local variables should be part of the language. There are heated discussions about how scaled integer arithmetic is an alternative to the complexity of floating point math. I don't mean there <i>were</i> those debates back in the day; I mean they still crop up now and again. <a href="http://yosefk.com/blog/my-history-with-forth-stack-machines.html">My history with Forth and stack machines</a> explains the Forth mindset better than I can, but beware: it's a warning as much as a chronology.</p><p>Though my fascination with Forth is long behind me, I still tend toward minimalist programming, but not in the same, extreme, way. I've adopted a more modern approach to minimalism:</p><blockquote><p>Use the highest-level language that's a viable option.</p><p>Lean on the built-in features that do the most work.</p><p>Write as little code as possible.</p></blockquote><p>The "highest-level language" decision means you get as much as possible already done for you: arbitrary length integers, unicode, well-integrated data structures, etc. Even better are graphics and visualization capabilities, such as in R or Javascript.</p><p>"Lean on built-in features," means that when there's a choice, prefer the parts of the system that are both fast--written in C--and do the most work. In Perl, for example, you can split a multi-megabyte string into many pieces with one function call, and it's part of the C regular expression library. Ditto for doing substitutions in a large string. In Perl/Python/Ruby, lean on dictionaries, which are both flexible and heavily optimized. I've seen Python significantly outrun C, because the C program used an off-the-cuff hash table implementation.</p><p>I've been mostly talking about interpreted languages, and there are two ways to write fast interpreters. The first is to micro-optimize the instruction fetch/dispatch loop. There are a couple of usual steps for this, but there's only so far you can go. The second is to have each instruction do more, so there are fewer to fetch and dispatch. Rule #2 above is taking advantage of the latter.</p><p>Finally, "write as little code as possible." Usual mistakes here are building a wrapper object around an array or dictionary and representing simple types like a three-element vector as a dictionary with x, y, and z keys, or worse, as a class. You don't need a queue class; you've already got arrays with ways to add and remove elements. Keep things light and readable at a glance, where you don't have to trace into layers of functions to understand what's going on. Remember, you have lots of core language capabilities to lean on. Don't insist upon everything being part of an architecture or framework.</p><p>This last item, write less code, is the one that the other two are building toward. If you want people to be able to understand and modify your programs--which is the key to open source--then have less to figure out. That doesn't mean fewer characters or lines at all costs. If you need a thousand lines, then you need a thousand lines, but make those thousand lines matter. Make them be about the problem at hand and not filler. Don't take a thousand lines to write a 500 line program.</p><p>(If you liked this, you might enjoy <a href="http://prog21.dadgum.com/202.html">The Software Developer's Sketchbook</a>.)</p></div></content>
</entry>
<entry>
<title>Optimizing for Human Understanding</title>
<link rel="alternate" type="text/html" href="http://prog21.dadgum.com/222.html"/>
<id>http://prog21.dadgum.com/222.html</id>
<published>2016-09-04T00:00:00-06:00</published>
<updated>2016-09-04T00:00:00-06:00</updated>
<author><name>James Hague</name></author>
<content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Long ago, I worked on a commercial game that loaded a lot of data from text files. Eventually some of these grew to over a megabyte. That doesn't sound like a lot now, but they were larger than the available buffer for decoding them, so I looked at reducing the size of the files.</p><p>The majority of the data was for placement of 3D objects. The position of each object was a three-element floating point vector delineated with square brackets like this:</p><pre>[ 659.000000 -148.250000 894.100000 ]</pre><p>An orientation was a 3x3 matrix, where each row was a vector:</p><pre>[ [ 1.000000 0.000000 0.000000 ]
  [ 0.000000 1.000000 0.000000 ]
  [ 0.000000 0.000000 1.000000 ] ]</pre><p>Now this format looks clunky here, but imagine a text file filled with hundreds of these. The six-digits after the decimal point was to keep some level of precision, but in practice many values ended up being integers. Drop the decimal point and everything after it, and the orientation matrix becomes:</p><pre>[ [ 1 0 0 ]
  [ 0 1 0 ]
  [ 0 0 1 ] ]</pre><p>which is a big improvement. In the vector example, there's "-148.250000" which isn't integral, but those last four zeros don't buy anything. It can be reduced to "-148.25".</p><p>The orientation still isn't as simple as it could be. It's clearly an identity matrix, yet all nine values are still specified. I ended up using this notation:</p><pre>[ I ]</pre><p>I also found that many orientations were simply rotations around the up vector (as you would expect in a game with a mostly flat ground plane), so I could reduce these to a single value representing an angle, then convert it back to a matrix at load time:</p><pre>[ -4.036 ]</pre><p>I don't remember the exact numbers, but the savings were substantial, reducing the file size by close to half. At the time the memory mattered, but half a megabyte is trivial to find on any modern system. This also didn't result in simpler code, because the save functions were now doing more than just <code>fprintf</code>-ing values.</p><p>What ended up being the true win, and the reason I'd do this again, is because it makes the data easier to visually interpret. Identity matrices are easy to pick out, instead of missing that one of the other values is "0.010000" instead of "0.000000". Common rotations are clearly such, instead of having to mentally decode a matrix. And there's less noise in "0.25" than "0.250000" (and come to think of it, I could have simplified it to ".25"). It's optimized for humans.</p><p>(If you liked this, you might enjoy <a href="http://prog21.dadgum.com/187.html">Optimization in the Twenty-First Century</a>.)</p></div></content>
</entry>
</feed>